0	40138	-1	1248066120	0	gowers	0. I'd just like to chip in here and say that solving an already solved problem in an open collaborative way is a great idea, as it is basically guaranteed to give us useful data about how such projects can work. I have not yet thought seriously about the problem myself, but I had a few preliminary thoughts offline before you suggested this, so I propose to wait for others to post similar thoughts before I make any comments.	???
1	40139	-1	1248066840	1	Cristina	1. Having seen the problem for the first time few minutes ago, the first reaction I have is to try some kind of variation on reductio ad absurdum. (I hope this kind of comment is in the spirit of the original idea -- I apologise in advance if I've stepped over the boundary of the experiment's rules) \emph{[This is definitely in the spirit of the experiment - T.]}	perf[suggest]( meta[strategy]( problem, raa ) )\newline rel[structural](problem,M)\newline rel[structural](problem, “{a_i}_i”)\newline rel[structural](“{a_i}_i”, n)\newline rel[structural](M,n)
2	40140	-1	1248068940	2	David Speyer	2. Two vague thoughts: (1) Let $C_n$ be the edge graph of the unit $n$ -cube: so $C_n$ has $2^n$ vertices and $n*2^{n-1}$ edges. There is an obvious map $p$ from the vertices of $C_n$ to the integers, sending the vertex $(i_1, i_2, ..., i_n)$ to the point $\sum i_j a_j$ . We would like to show that $p^{-1}(M)$ cannot disconnect $C_n$ . Is there some classification of sets that disconnect $C_n$ ? Is there some measure of size (probably not simple cardinality) in which $p^{-1}(M)$ is too small to disconnect? (2) I'd like to induct on $n$ . I tried to set it up a few times and failed, but maybe someone else can do better.	perf[define]( C_n )\newline perf[define]( p )\newline rel[structural](C_n, n)\newline rel[structural](p, C_n)\newline rel[structural](p, “{a_i}_i”)\newline \newline perf[suggest]( meta[goal]( inv_disc_M ) )\newline rel[structural](inv_disc_M, M)\newline rel[structural](inv_disc_M, p)\newline rel[structural](inv_disc_M, C_n)\newline \newline perf[queryE](X, inv_disc( X ) )\newline \newline perf[queryE](Y, notion_too_small(Y) )\newline \newline perf[suggest](meta[strategy]( inv_disc_M , induction_n ) )\newline rel[structural](induction_n, n)\newline \newline ???
3	40141	-1	1248069000	-1	Haim	\sout{2} 3. The following reformulation of the problem may be useful: Show that for any permutation s in Sn, the sum $a_s(1)+a_s(2)\ldots +a_s(j)$ is not in M for any $j\leq n$. Now, we may use the fact that Sn is ''quite large'' and prove the existence of such permutation with some kind of a pigeonhole-ish principle.	perf[assert](rel[equivalent](problem, perm_view)))\newline rel[structural](perm_view, Sn)\newline rel[structural](perm_view, M)\newline rel[structural](perm_view, “\{a_i\}_i”) \newline rel[structural](Sn,n)\newline \newline perf[suggest](meta[goal](perm_view))\newline \newline sn_large = perf[assert](rel[has_property](S_n, large))\newline \newline perf[suggest](meta[auxiliary](meta[strategy](perm_view, pigeonhole), sn_large))
4	40142	-1	1248069060	-1	Michael Lugo	\sout{2} 4. If n = 2, the problem reduces to: let $a_1$, $a_2$ be distinct positive integers, and let $m$ be a positive integer which is not $s = a_1 + a_2$.  A grasshopper is to jump along the real axis, starting at the point $0$ and making two jumps $a_1$, $a_2$.  Prove that the order can be chosen in such a way that the grasshopper never lands on m. In this case, the desired result is obvious; the sequence of points landed on is either $(a_1, a_1 + a_2)$ or $(a_2, a_1 + a_2)$.  If m is not a_1 or a_2 we can pick either sequence; if m is one of those we pick the other one. This could be the base case for some induction on n.	perf[assert]( problem_for_two )\newline perf[assert]( rel[instance_of]( problem, problem_for_two ) )\newline perf[apply]( meta[strategy]( problem, induction_n ) )\newline rel[instantiate](n,2)\newline rel[structural](problem_for_two, 2)
5	40143	-1	1248069060	-1	Haim	\sout{2} 5. The following reformulation of the problem may be useful: Show that for any permutation s in Sn, the sum a_s(1)+a_s(2)\ldots +a_s(j) is not in M for any j=<n. Now, we may use the fact that Sn is ''quite large'' and prove the existence of such permutation with some kind of a pigeonhole-ish principle	repeated comment
6	40144	-1	1248069360	6	Michael Lugo	6. This is an administrative comment: there are now four comments numbered ``2''.  Is it possible to clean this up? \emph{[Now doing so - T.]} (Incidentally, I know I've seen blogs -- and I'm pretty sure they were WordPress blogs -- that automatically numbered the comments.  I'm not sure how to activate this, but it might be useful for this post and others in the ``polymath'' vein.)	???
7	40145	-1	1248069420	7	Nate	7. Well, my first thought is to see if the hypotheses seem reasonable. The hypothesis that $s= a_1 + \ldots  + a_n$ not lie in M is certainly necessary, as the last jump that the grasshopper takes will land on s.  The grasshopper's other steps will land on a partial sums $a_{\sigma(1)} + \ldots  + a_{\sigma(k)}$ for some permutation $\sigma$, but we get to choose the permutation.  Thus it seems plausible that we can avoid a given set of n-1 points.	perf[assert]( rel[equiv]( problem, perm_view2 )\newline perf[assert]( judge[plausible]( perm_view2 ) )\newline rel[structural](perm_view2, Sn)\newline rel[structural](perm_view2, M)\newline rel[structural](perm_view2, “{a_i}_i”) 
8	40146	-1	1248069540	-1	Thomas	\sout{2} 8. Quick observation. The grasshopper must make a first step. This is always possible, since the a_i are distinct and |M|=n-1; that is, there is always an a_i not in M. However, let's say M matches all but one of the a_i. Then the first step is uniquely determined. Still, according to the claimed theorem, a second step must still be possible.	perf[assert]( first_step_exists )\newline rel[structural](first_step_exists, “{a_i}_i”)\newline \newline perf[assert]( rel[instance_of]( problem, all_but_one ) )\newline perf[assert]( rel[has_property](all_but_one, first_step_unique ) )\newline perf[query]( rel[has_property](all_but_one, second_step ) )\newline rel[structural](all_but_one, M)\newline rel[structural](all_but_one, “{a_i}_i”)
9	40147	-1	1248069600	-1	Haim	\sout{3} 9. Following ( \sout{2} 3); For any x in M, there are two possibilities: 1. x can't be represented as a sum of (distinct) ai's. 2. x=a_j1+a_j2\ldots +a_jk. In this case, we may assign x the set {j1, j2\ldots jk} So M can actually be regarded as a subset of P({1, 2\ldots n})	perf[assert](rel[equivalent]( problem, powerset_view ) )
10	40148	-1	1248069660	-1	Dave	\sout{1} 10. Addressing Michael Lugo: I think he means number just your own comments, and then address a (person,number) pair. \emph{[Actually, I was proposing a global numbering system; I'll try to fix it up now.  But the (author, number) pair approach would also have worked, except perhaps for anonymous comments. -T]} Addressing Haim( \sout{2} 5): That's pretty strong; all you need is that there exists a permutation where that is true. And it doesn't work; there are numbers $a_1,a_2,\ldots,a_n$ and sets $M$ of $n-1$ points such that, for instance, $a_1 \in M$. Then any permutation starting with $a_1$ would not satisfy your conjecture for $j=1$. But, just looking for *one* permutation that satisfies $a_s(1)+a_s(2)\ldots +a_s(j) \not \in M$ for any $j \leq n$ (which is basically the statement of the theorem), could lend itself well to induction. In other words, use the fact that for every subset $M' \subset M$ of size $j$ not containing $a_s(1)+a_s(2)\ldots +a_s(j)$, there is a way to permute those $j$ numbers to avoid $M'$.	perf[challenge]( perm_view , a1_ex)\newline rel[instantiate](a_1, “a_1”)\newline rel[structural](a1_ex, “a_1”)\newline rel[structural](“{a_i}_i”, a_1)\newline \newline perf[suggest](meta[goal](perm_view_mod)) \newline rel[structural](perm_view_mod,Sn)\newline rel[structural](perm_view_mod,M)\newline rel[structural](perm_view_mod, “{a_i}_i”)\newline \newline perf[suggest](meta[strategy](perm_view_mod, strong_induction_n))\newline rel[structural](strong_induction_n, n)
11	40149	-1	1248069720	-1	Anonymous	\sout{2} 11. The scorings of this problem accroding to the offical result are: Score    Number of Particpants 0           540 1           2 2           1 3           10 4           6 5           2 6           1 7           3 A score of 1-6 represents partial credit.	???
12	40150	-1	1248070200	12	Haim	12. Addressing Dave: Sorry, indeed I meant: ``Show that for *one* permutation\ldots ''	perf[retract](perm_view)\newline perf[agree](perm_view_mod )
13	40151	-1	1248070680	-1	David Speyer	\sout{2} 13. Regarding Haim( \sout{3} 9) Unfortunately, the same integer may occur as the sum of many different subsets of M. For example, if M = {1,2,3}, do you assign the integer 3 to {3} or to {1,2}?	perf[challenge]( not_welldef, rel[equivalent]( problem, powerset_view ) )\newline rel[structural](not_welldef, M)\newline rel[structural](not_welldef, “{a_i}_i”)
14	40153	-1	1248071640	14	neal	14. can M really be regarded as a subset of P when P({1,2,\ldots ,n}) since M is a set of n-1 positive integers not containing s, and not necessarily the set of {1,2,\ldots ,(n-1)}	perf[challenge]( def_of_M, rel[equivalent]( problem, powerset_view ) )\newline rel[structural](def_of_M, M)
15	40154	-1	1248071760	-1	Haim	\sout{5} 15. (I'm lost with the numbering of comments) To David: You're right. Instead, we may take a set of the largest possible size, and if there are two such sets, we may order their elements, and take the larger tuple in the lexicographical order. Now, this may be useful: note that M does not contain a1+a2+\ldots +an, so each x in M must be assigned to some j-tuple with j<n. Perhaps we should look for some surjective mapping from Sn to the set of <n-tuples that will assert the existence of the desirable permutation\ldots 	perf[retract]( rel[equivalent]( problem, powerset_view ) )\newline \newline perf[define]( assignment )\newline perf[assert]( rel[has_property]( assignment, small_image )\newline \newline perf[suggest]( meta[strategy]( problem, find_surj_mapping ) )\newline rel[structural](find_surj_mapping, Sn)]
16	40156	-1	1248071880	16	neal	16. nevermind. my mistake	perf[retract]( perf[challenge]( def_of_M, rel[equiv]( problem, powerset_view ) ) )
17	40161	-1	1248072300	17	k	17. we need to show that there is a permutation $\sigma$ that no partial sum $a_{\sigma(1)}+ \ldots + a_{\sigma(j)}, j = 1,2,..n$ is in the set M. we can assume that the numbers $a_1, a_2,.. a_n$ are in increasing order. if M does not intersect the interval $[a_1, s=a_1+a_2..a_n]$ then any permutation $\sigma$ would do. so we assume that max M is less or equal to s. choose the initial step $a_j$ where j is the smallest index j so that $a_j$ is not in M. this is possible because M has only n-1 elements. now replace the set M by $M_1 = M - a_j = m - a_j: m in M$, remove $a_j$ and set $\sigma_1 = j.$ i need to work on  how to make the next step or use induction on j	perf[suggest]( meta[goal]( perm_view2 ) )\newline perf[assert]( rel[wlog]( problem, problem_ordered ) )\newline perf[assert]( rel[wlog]( problem_ordered, problem_ordered_max ) )\newline perf[suggest]( meta[strategy]( constructive ) )\newline rel[structural](problem_ordered, “{a_i}_i” )\newline rel[structural](problem_ordered_max, “{a_i}_i”)
18	40162	-1	1248072600	18	gowers	18. OK, there have been enough comments that I feel I can make my very preliminary, and not obviously helpful, observation. It's that if on the first step you can get past a forbidden number then you are done by induction. However, since there is absolutely no reason to be able to do that on the first step, I think this is probably not the way to go. I'm tempted to try proving it for $n=3$ by an ugly method. In fact, here is an attempt at that. Let the numbers be $a,b$ and $c$.  We're trying to get to $a+b+c$ . Let's write down the first two steps of all six possible routes: $(a,a+b)$ , $(a,a+c)$ , $(b,b+a)$ , $(b,b+c)$ , $(c,c+a)$ , $(c,c+b)$ . Can we find two numbers that intersect all these pairs? The answer isn't instantly obvious, so let's experiment with blocking $a$ and $b+c$ to see what happens. Then the only possibilities left are $(b,b+a)$ and $(c,c+a)$ . We know that we have not covered $b$ or $c$ . Actually, we haven't covered $b+a$ either (since $a>0$ and $a\ne c$ ). To be more systematic, we have to see what the possible equalities are between the various numbers. We know that $a,b$ and $c$ are distinct. Also, $a+b$ , $b+c$ and $a+c$ are distinct (subtract them from $a+b+c$ ). So the only possible equalities are things like $a=b+c$ , Moreover, only one such equality can hold, since the number that equals the sum must be the biggest of the three. So let's suppose WLOG that $b\ne a+c$ and $c\ne a+b$ . Then the pairs $(a,a+b)$ , $(b,a+b)$ , $(a,a+c)$ and $(c,a+c)$ have only the obvious equalities. The only way of blocking all four of these paths is to take $a+b$ and $a+c$ . But that leaves the path $(b,b+c)$ . (It's possible that $a=b+c$ here, but we were forced not to block $a$ .) I don't see a general argument coming out of this just yet, but a few little ideas might perhaps be developed.	perf[apply](induction, special_jumpcase)\newline perf[assert](special_jumpcase)\newline \newline perf[assert]( rel[not]( perf[equiv]( special_jumpcase, problem ) ) )\newline perf[assert]( rel[instance_of]( problem, prob_with_3 ) )\newline perf[assert]( prob_with_3 )\newline rel[instantiate](n,3)\newline rel[structural](prob_with_3, 3)
19	40163	-1	1248072840	20	David Speyer	20 I think I'm the one who screwed up the comment numbering, so I apologize. I'm going to number this as comment 20, and hopefully we can do sequential numbering from now on. \emph{[My count gives 19, but it should be OK to have gaps.  A good rule would be: when in doubt, make the number bigger.]}	???
20	40166	-1	1248073020	21	KK	21. Forgive me for the silly image but that's the only way I can''feel'' the problem. I imagine our grasshopper hero going from 0   to s in n distinct jumps whose lengths are given (a1,a2,\ldots ,an) .But there are some numbers x (x belongs to M) where a landmine is placed and if our buddy falls there, game over. Now I am only guessing but I think that if we prove that we can find a sequence even for the worst case (n-1 landmines i.e all x between 1 and s-1) we have solved our problem. As it has been suggested we could try induction (for each step an unused ai can be  choose so we can avoid the landmines) or we can try a combinatorial approach and prove that there is at least one sequence a1.a2\ldots an  whose set of partial sums  is disjointed from M. Are these really two really different approaches? A local , step by step on (by Induction) and a global one by combinatorics? or is the same since the induction would need combinatorics?	perf[define]( landmine )\newline rel[structural](landmine, M)\newline \newline perf[assert]( rel[wlog]( problem, problem_max ) )\newline \newline perf[suggest]( meta[strategy]( problem, induction_n )\newline \newline perf[suggest]( meta[strategy]( problem, combinatorics ) )\newline \newline perf[query]( rel[equivalent]( induction_n, combinatorics ) )
21	40167	-1	1248073140	22	Louigi	22. Just a quick thought after having read the problem description and the current replies. It is certainly not the case that for fixed M, *any* permutation $\sigma:\{1,\ldots,n\} \rightarrow \{1,\ldots,n\}$ will yield a sequence of steps $a_{\sigma(1)},a_{\sigma(1)}+a_{\sigma(2)},\ldots$ that avoid M. But maybe the following statement, stronger than the original claim, is true: for fixed M and any permutation $\sigma:\{1,\ldots,n\} \rightarrow \{1,\ldots,n\}$ , some cyclic permutation of $\sigma$ will yield a sequence of steps that avoid M. I haven't thought about this approach so maybe there is an easy counterexample.	perf[assert]( rel[not]( perm_view ) )\newline \newline perf[suggest]( meta[goal]( cyclic_pb ) ), perf[assert]( rel[stronger]( cyclic_pb, problem ) )\newline rel[structural](cyclic_pb, M)\newline rel[structural](cyclic_pb, “{a_i}_i”) 
22	40168	-1	1248073320	23	David Speyer	23: ``maybe the following statement \ldots  is true: for fixed M \ldots  some cyclic permutation of $\sigma$ will yield a sequence of steps that avoid M.'' Sadly, false. Take (a_1, a_2, a_3) = (1,2,3) and take M = {2,3}. Then none of the cyclic permutations work. I like the idea of using a smaller group than the full symmetric group, though.	perf[challenge]( cyclic_pb )\newline \newline perf[challenge](cyclic_pb, 123_ex)\newline rel[instantiate](n,3)\newline rel[instantiate](a_1, 1)\newline rel[instantiate](a_2, 2)\newline rel[instantiate](a_3, 3)\newline rel[structural](“{a_i}_i”, a_1)\newline rel[structural](“{a_i}_i”, a_2)\newline rel[structural](“{a_i}_i”, a_3)\newline rel[instantiate](M, “{2,3}”)\newline \newline perf[suggest]( meta[strategy]( perm_view2, restrict_perms ) )
23	40169	-1	1248073560	-1	liuxiaochuan	\sout{6} 24 I'm thinking about the possibility of transforming this problem into another, where there are several ways to travel from one point to another, and M regulates which ways can't be chosen.	perf[suggest]( meta[strategy]( problem, regulate_M) ) 
24	40170	-1	1248073920	-1	mircea	\sout{1} 25. My first ideas: - without loss of generality $M$. is a subset of $A:=\{1,\ldots,s-1\}$, where $s:=a_1+\ldots+a_n$. - Let $F$ be the set of possible sums $S_{\sigma,j} $ for $\sigma\in S_n$ and $j\leq n$, as described by Haim(2).  What properties does this set have? One symmetry is as follows: consider $A$ as a set of $s-1$ ordered beads, of which the ones corresponding to $F$ are colored.  So $F$ can be considered as a coloring of a set of beads. Then consider a MOVE, given by taking a segment $b_1,\ldots,b_k$ of ordered beads, of which the _first_ and the _last_ are colored. Then reverse its order. now you have a new coloring of the beads. I claim that the set $F$ of colored beads is invariant under any MOVE. Is it also characterized by this?(ehm..in some sense?)	perf[assert]( rel[wlog]( problem, problem_max ) )\newline rel[structural](problem_max, M)\newline rel[structural](problem_max, “{a_i}_i”)\newline \newline perf[define]( F )\newline rel[structural](F, “{a_i}_i”)\newline \newline perf[queryE]( X, has_property( F, X ) )\newline \newline perf[define]( necklace )\newline rel[structural](necklace, F)\newline \newline perf[define]( move )\newline \newline perf[suggest]( meta[goal] ( necklace_invariance ) )\newline \newline perf[query]( rel[equivalent]( necklace_invariance, problem ) )
25	40171	-1	1248073920	-1	KK	\sout{24} 26. Sorry for not putting the comment number before :( . I just thought, if this can be proven by induction is equivalent to give an algorithm for the sequence right?  I dont know maybe something like find the first member of M , use the most/least  ai to arrive to a number before it, then use some criteria to select ai to jump over the members of M  which could be together or very close and so on. Sorry for the rambling but I would like to see a nice algorithm for this :)	perf[suggest]( meta[strategy]( constructive ) )
26	40172	-1	1248074160	27	gowers	27. A vague thought that came out of the brute-force approach to the case $n=3$ . It seems that the more coincidences there are amongst the finite sums of the $a_i$ , the harder it is for the grasshopper, since the landmines (if we go with that image) can block several paths at once. So it ought, for instance, to be easy to prove that the grasshopper wins if $a_i=2^{i-1}$ (so that all sums are distinct). In fact, here's a quick proof. There are $n!$ distinct paths, and any landmine rules out $k!(n-k)!$ of them for some $k$ . But this is maximized when $k=1$ (since $k=0$ and $k=n$ are forbidden), so we can't rule out more than a proportion $n^{-1}$ of all paths. So we are done. At the opposite extreme is the case when $a_i=i$ . Now there are lots of coincidences amongst the sums. Does anyone have an argument for this special case? Morally, it ought to be the hardest, but that doesn't mean it's as hard as the whole problem, since the difficulty might lie in actually proving that it's the extreme case.	perf[assert]( judge[difficult]( close_together ) )\newline perf[assert]( rel[instance_of]( problem, close_together ) )\newline \newline perf[assert]( rel[instance_of]( problem, powers_two ) )\newline perf[assert]( judge[easy]( powers_two ) )\newline rel[structural](powers_two, “{a_i}_i”)\newline \newline perf[assert]( powers_two )\newline \newline perf[assert]( rel[instance_of]( problem, i_to_i ) )\newline rel[structural](i_to_i, “{a_i}_i”)\newline \newline perf[query]( judge[difficult]( powers_two ) )\newline \newline perf[suggest]( meta[strategy]( worst_case ) ), perf[query]( i_to_i_worst_case )
27	40173	-1	1248074280	-1	Omar	Generalizing gowers's comment, if for any k<n we can find k of the a_i whose partial sums avoid M and whose sum gets you past at least k of the elements of M, then you can finish by induction. So an indecomposable instance of the problem is one for which the smallest k with the property above is k=n, these are the ones that don't directly fall to induction.	perf[assert]( special_jumpcase_k ), perf[assert]( rel[stronger]( special_jumpcase_k, special_jumpcase))\newline \newline perf[assert]( rel[wlog]( indec_instance ) )
28	40174	-1	1248075660	-1	mircea	\sout{2} 28. (variant of Louigi's approach) if you start with a given $\sigma$ then maybe it can be useful to iterate ``exchanging $2$ successive jumps to avoid an element of $M$ '' (this uses the case $n=2$ discussed by Michael Lugo ( \sout{2} 4)).. in other words you compose your permutation with inversions, or $2$ -cycles	perf[apply]( constructive, problem )\newline \newline perf[suggest]( meta[strategy]( constuct_by_move ) )
29	40175	-1	1248075780	29	pz	29. Addressing 1 (reductio ad absurdum). Suppose there exists an $M$ such that every grasshopper walk must pass through at least one point of $M$. Wlog let $M = \{ S_{k_1}, S_{k_2}, \ldots , S_{k_{n-1}}\}$ where each $S_{k_j}$ is a sum of $k_j$ integers $a_i$. For each $S_{k_j}$, we have that at most $(k_j)!(n-k_j)!$ grasshopper walks must pass through the point $S_{k_j}$. Since the total number of walks is n!, we must have: $(k_1)!(n-k_1)! + (k_2)!(n-k_2)! + \ldots  + (k_{n-1})!(n-{k_{n-1}})! \geq n!$ Clearly the left hand side is at most $(n-1) (n-1)!$. Hence we have $n-1 > n$. QED.	perf[apply]( raa, problem ) \newline \newline perf[assert]( rel[wlog]( rel[not]( problem ), M_choice) )\newline perf[assert]( rel[not]( M_choice ) )\newline rel[structural](M_choice, M)
30	40176	-1	1248076200	30	pz	30. Re my previous post: This was too simple, so there must be a mistake in my proof. What is it?	TODO: too meta to code?
31	40177	-1	1248076260	-1	Mohammad	\sout{1} 31. Quick thought following on David Speyer's first comment:  The problem asks us to prove that no set of size (n-1) can disconnect two diagonally opposing vertices in the n-cube.  By Menger's theorem, this is equivalent to proving that there are n internally vertex-disjoint paths between these two vertices.  So, now we are faced with a constructive problem, independent of the set M:  Construct n vertex-disjoint paths from $0^n$ to $1^n$ in the n-cube.	perf[suggest]( meta[goal]( disj_path ) )\newline perf[assert]( rel[independent_of]( disj_path, M ))\newline rel[structural](disj_path, n)\newline \newline perf[apply]( menger_thm, inv_disc_M )\newline \newline perf[assert]( rel[equivalent]( inv_disc_M, disj_path ) )
32	40179	-1	1248076380	32	mircea	32. @pz: it is that you assume ``wlog'' a fact which is not a ``generic'' bad case. In the generic bad case only one of the sums $S_{k}$ belongs to M.	perf[challenge]( rel[wlog]( rel[not]( problem ), M_choice ) )
33	40183	-1	1248076620	-1	David Speyer	\sout{32} 33: To pz: the mistake is that the same element of $M$ can be written as a sum of $a_i$ in many ways, and can thus block many more than $k!(n-k)!$ paths. For example, if $(a_1, a_2, a_3) = (1,2,3)$, then putting 3 into M blocks four paths. To Mohammed, easy enough to do: look at the $n$ paths $e_1, e_1+e_2, \ldots , e_1+e_2+\ldots +e_n e_2, e_2+e_3, \ldots , e_2+e_3+\ldots +e_1 \ldots  e_n, e_n+e_1, \ldots$  Unfortunately, I think we are in a rut here.	perf[challenge]( rel[not]( M_choice ) )\newline \newline perf[challenge]( rel[not]( M_choice ), 123_ex1 )\newline \newline perf[assert]( disj_path )
