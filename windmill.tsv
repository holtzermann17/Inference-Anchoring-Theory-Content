1	Richard McCart	August 22, 2011 @ 3:52 am	Could you start off with a random point in the plane and prove it doesn't work, if you can't prove that then the opposite holds.	rel[structural](problem, S)\newline rel[structural](problem, P)\newline rel[structural](problem, l)\newline rel[structural](problem, windmill)\newline rel[structural](problem, pivot)\newline rel[structural](P, pivot)\newline rel[structural](P, windmill)\newline rel[structural](l, windmill)\newline perf[query](random_test_false)\newline perf[assert](rel[stronger](rel[not](prove_rtf), rel[not](random_test_false)))\newline rel[structural](random_test_false, prove_rtf)	Conjecture
2	Gal	July 19, 2011 @ 8:07 pm	Connecting the dots: At the point where the pivot changes we create a line that passes through the previous pivot and a new pivot -- like a side of a polygon.	perf[define](pivot_seq, ps_def)\newline rel[structural](pivot_seq, pivot)	Concept
2.1	Garf	July 19, 2011 @ 8:23 pm	Nice. We need only to consider the times when to points are connected -- this gives us a path, and after some time this path will come back to some already visited point. So there is a cycle. If only we could find a cycle which spans all the points, the question is solved\ldots That may be some useful simplification.	perf[assert](rel[has_property](pivot_seq, has_cycle))\newline perf[suggest](meta[goal](cycle_spans_S))\newline perf[judge](value[useful](pivot_seq))\newline rel[structural](S, cycle_spans_S)	Conjecture
2.1.1	Gal	July 19, 2011 @ 8:37 pm	Isn't there always a cycle that spans all the points? The problem imposes restrictions on the cycles we can choose, right?	perf[assert](not_any_cycle)	Conjecture
2.1.1.1	Gal	July 19, 2011 @ 8:56 pm	For example, the restriction on how the next pivot is chosen (geometrically: comment 9). Are there any other restrictions? Can we start with a complete graph and all cycles on that graph and just discard the ones that don't follow the restrictions to converge on the ones that do?	queryE(additional_condition_on cycles(X))\newline perf[suggest](meta[strategy](cycle_spans_S, process_of_elim))\newline rel[structural](process_of_elim, additional_conditions_on cycles)\newline ???	Concept
2.1.1.1.1	CLH	July 19, 2011 @ 9:31 pm	The line must sweep out a full rotation (and only one full rotation) of $2\pi$ during the traversal of $S$. I feel like this is intimately related to proving that there is a starting angle for any point $P$ in $S$ such that all of $S$ is then traversed. I'm trying to show this by induction. 	perf[assert](one_turn)\newline perf[judge](value[useful](one_turn))\newline perf[suggest](meta[strategy](problem, induction))\newline rel[structural](one_turn, windmill)\newline rel[structural](one_turn, line)\newline rel[structural](one_turn, S)\newline rel[structural](S, n)\newline rel[structural](induction, n)\newline rel[structural](induction, BC)\newline rel[structural](induction, IH)	Proof
---	CLH	July 19, 2011 @ 9:31 pm	Base case ($|S|=2$) is obvious.	perf[assert](BC)	Proof
---	CLH	July 19, 2011 @ 9:31 pm	 Let $|S| = n$, take $S' = S \cup \{Q\}$, and start with some windmill traversal of $S$.	perf[assert](rel[case_split](IS, IS_A, IS_B))	Proof
---	CLH	July 19, 2011 @ 9:31 pm	Case A: $Q$ is unreachable. Therefore we just traverse $S$, taking $2\pi$ to do so by induction.	perf[assert](IS_A, IS_A_proof)	Proof
---	CLH	July 19, 2011 @ 9:31 pm	Case B: $Q$ is reachable at some angle $\Omega_0$ from $P_0$ in $S$	perf[assert](rel[case_split](IS_B, IS_B1, IS_B2))	Proof
---	CLH	July 19, 2011 @ 9:31 pm	-- Case 1: the next point to be reached is the same as before (e.g. $S_k \rightarrow Q \rightarrow S_{k+1} \rightarrow S_{k+2}$ instead of $S_k \rightarrow S_{k+1} \rightarrow S_{k+2}$). Previously, the radians traversed by the line for this transition was $A_1 + A_2$. Now it's $(A1-\Omega_0) + \Omega_0 + \Omega_1 + (A_2 -- \Omega_1) = A1+A2$. Then we proceed through $S$, taking the remainder of $2\pi$ remaining.	perf[assert](IS_B1, IS_B1_proof)	Proof
---	CLH	July 19, 2011 @ 9:31 pm	-- Case 2: We go through $Q$ again. This is effectively the same thing, but now you segment the angle few more times: $(A_1 - \Omega_0) + \Omega_0 + \Omega_1 + \Omega_2 + \ldots + (A_2 - \Omega1 - \Omega2 - \ldots)$	perf[assert](IS_B2, IS_B2_proof)	Proof
---	CLH	July 19, 2011 @ 9:31 pm	-- Case 3: We go to a different point in $S$ (having trouble here)	???	Proof
2.2	Anonymous	July 19, 2011 @ 8:28 pm	Or like an edge of a graph, and each edge leads to another edge. We want to show that there's a circuit that visits every vertex at least once. Ideas?	perf[define](pivot_seq, ps_def)\newline perf[suggest](meta[goal](cycle_spans_S))	Concept
2.2.1	Garf	July 19, 2011 @ 8:37 pm	Is it me, or you can get a partition of the set of directed edges on this graph into admissible cycles (i.e., cycles generated by the windmill process) ? You juste have to reverse the time if necessary\ldots	perf[assert](cycle_partition, rev_time_pf)\newline rel[structural](cycle_partition, windmill)	Conjecture
2.2.1.1	Austin	July 19, 2011 @ 8:43 pm	I believe this is true. It proves that it's enough to find a cycle that visits each vertex at least once.   there are no ``rho'' processes with an initial segment that doesn't repeat.	perf[agree](cycle_partition)\newline perf[assert](rel[equivalent](problem, forall_exists_problem), cycle_partition)	Conjecture
3	Anonymous	July 19, 2011 @ 8:08 pm	If the points form a convex polygon, it is easy.	perf[judge](value[easy](S_is_conv))	Examples
3.1	Thomas H	July 19, 2011 @ 8:09 pm	Yes. Can we do it if there is a single point not on the convex hull of the points?	perf[agree](S_is_conv)\newline perf[query](rel[has_property](convex_plus_point, cycle_spans_S)\newline rel[instance_ofl](S, convex_plus_point)	Examples
3.1.1	Jerzy	July 19, 2011 @ 8:17 pm	Say there are four points: an equilateral triangle, and then one point in the center of the triangle. No three points are collinear. It seems to me that the windmill can not use the center point more than once! As soon as it hits one of the corner points, it will cycle indefinitely through the corners and never return to the center point. I must be missing something here\ldots	perf[assert](rel[instance_of](convex_plus_point, equi_tri))\newline perf[assert](rel[instance_of](S, equi_tri))\newline perf[assert](rel[has_property](equi_tri, not_colin))\newline perf[challenge](problem, equi_tri_stuck)\newline rel[structural](equi_tri, equi_tri_stuck)\newline perf[judge](rel[not](value[plausible](equi_tri_stuck)))	Concept
3.1.1.1	Joe	July 19, 2011 @ 8:21 pm	This isn't true -- it will alternate between the centre and each vertex of the triangle.	perf[challenge](equi_tri_stuck, alternate)	Concept
3.1.1.2	Thomas H	July 19, 2011 @ 8:21 pm	No, you're not right. Let the corner points be A, B, C, clockwise, M the center. If you start in M, you first hit say A, then C, then M, then B, then A.	perf[challenge](equi_tri_stuck, alternate1)	Proof
3.1.1.2.1	Jerzy	July 19, 2011 @ 8:31 pm	Ohhh\ldots I misunderstood the problem. I saw it as a half-line extending out from the last point, in which case you would get stuck on the convex hull. But apparently it means a full line, so that the next point can be ``behind'' the previous point. Got it.	perf[retract](perf[challenge](problem, equi_tri_stuck))\newline perf[assert](rel[not](half_line))\newline rel[structural](line, half_line)	Concept
3.1.1.2.1.1	Dan Hagon	July 19, 2011 @ 8:44 pm	Yeah, so it's an infinite line extending in both directions and not just a ray. I'm thinking spirograph rather than convex hull.	perf[agree](rel[not](half-line))\newline perf[suggest](meta[strategy](problem, spirograph))	Concept
3.1.1.2.1.1.1	Manjunath Mc	July 20, 2011 @ 6:09 am	Yeah, Spirograph seems to be worth a try\ldots	perf[judge](value[useful](meta[strategy](problem, spirograph)))	Concept
4	Haggai Nuchi	July 19, 2011 @ 8:08 pm	The first point and line P_0, l_0 cannot be chosen so that P_0 is on the boundary of the convex hull of S and l_0 picks out an adjacent point on the convex hull. Maybe the strategy should be to take out the convex hull of S from consideration; follow it up by induction on removing successive convex hulls.	perf[assert](rel[has_property](two_conseq_hull, not_all_paths))\newline rel[structural](not_all_paths, convex_hull)\newline perf[suggest](meta[strategy](problem, induction_hulls))\newline rel[structural](induction_hulls, convex_hull)\newline rel[structural](convex_hull, S)\newline rel[structural](two_conseq_hull, pivot_seq)	Conjecture
4.1	Haggai Nuchi	July 19, 2011 @ 8:10pm	More specifically, remove the subset of S which forms the convex hull to get S_1; remove the new convex hull to get S_2, and repeat until S_n is convex. Maybe a point of S_n is a good place to start.	perf[suggest](meta[strategy](problem, induction_hulls_detail))\newline rel[structural](induction_hulls, induction_hulls_detail)	Proof
4.1.1	Srivatsan Narayanan	July 19, 2011 @ 8:37 pm	Can we just assume by induction that we have proved the result for all the ``inner points'' $S_2 \cup S_3 \cdot \cup S_n$. The base case would be that $S = S_1$, i.e., it forms a convex polygon.	perf[suggest](meta[strategy](problem, strong_ind_hulls))\newline perf[assert](rel[case_split](strong_ind_hulls, strong_ind_hulls_BC, strong_ind_hulls_IH))\newline perf[assert](strong_ind_hulls_BC)	Proof
4.1.2	Anonymous	January 19, 2012 @ 7:59 pm	I hope this hasn't been said already, but this seems close to me. Consider one convex hull $\{ p1, p2, \ldots\}$ inside another $\{q1, \ldots\}$, and suppose that a line pivoting on $p_i$ needs to sweep out some angle $\alpha$ to reach $p_{i+1}$. Then I think that even if there are points $q_{j_1}, q_{j_2}, \ldots$ between $p_i$ and $p_{i+1}$, the line keeps advancing until it starts to pivot on $p_{i+1}$. If this could be extended to many hulls then we may be done.	perf[assert](two_hulls)\newline perf[suggest](meta[goal](generalize_hulls))\newline perf[assert](rel[instance_of](generalize_hulls, two_hulls))	Proof
4.1.2.1	Anonymous	January 19, 2012 @ 8:05 pm	(apologies for doing my latex wrong). I just wanted to clarify, though, that a line advances if it passes over the sector with center $[q_i]$ and boundary equal to the starting point of $[l]$ and angle $[\alpha]$. Once the whole sector is on the other side of $[l]$ , then I believe we will have hit $ [q_{i+1}]$	perf[assert](two_hulls_detail)\newline rel[structural](two_hulls_detail, two_hulls)	Proof
5	Nemanja	July 19, 2011 @ 8:08 pm	Trivial observation: If we start with a point on the convex hull of S and a line $l$ that is ``tangent'' to the convex hull then we will only iterate over the points from the convex hull.	perf[assert](rel[has_property](S, not_all_paths))	Examples
6	Jerzy	July 19, 2011 @ 8:14 pm	Minor typo in the problem statement: I assume the last line should be ``each point of *S* as a pivot\ldots'' [Corrected, thanks -- T.]	???	Other
7	Kristal	July 19, 2011 @ 8:15 pm	 looks to me like we could take the convex hull of all the points and ignore all the points that are in the interior. Then the windmill process would work its way through the exterior points in an infinite cycle while never passing through the interior hence missing all the interior points and allowing them to be ignored.	perf[assert](rel[has_property](S, not_all_paths_detail))\newline perf[challenge](problem, rel[has_property](S, not_all_paths_detail))\newline rel[structural](not_all_paths, not_all_paths_detail)	Conjecture
7.1	Kristal	July 19, 2011 @ 8:28 pm	To be specific choose one of the points not in the interior of the convex hull and a line which doesn't pass through the interior of the convex hull.	***counting this in not_all_paths_detail	Examples
7.2	Jerzy	July 19, 2011 @ 8:33 pm	I think I started with the same misunderstanding as you. Don't imagine rotating a half-line extending out (in one direction) from the new point, but rather a full line extending out in both directions.	perf[challenge](perf[challenge](problem, rel[has_property](S, not_all_paths_detail)l), rel[not](half_line))	Other
7.2.1	--	July 19, 2011 @ 9:35 pm	I don't follow. Take three points forming an equilateral triangle, and a fourth in the middle (interior of the triangle, not on the boundary of the triangle). Start with one of the vertices of the triangle as a pivot for the line $l$. Then $l$ rotates clockwise until it hits another triangle vertex (thus laying over an `edge' of the triangle), and switches its pivot to the new vertex. When does $l$ ever pivot around the interior point?	perf[challenge](perf[challenge](perf[challenge](problem, rel[has_property](S, not_all_paths_detail)), rel[not](half_line)), not_all_paths_detail_detail)	Examples
7.2.1.1	--	July 19, 2011 @ 9:43 pm	EDIT: I follow now. In the above setup, it suffices to start with the interior point as initial pivot. I misunderstood the question.	perf[retract](perf[challenge](problem,rel[has_property](S, not_all_paths_detail), start_int)\newline rel[structural](start_int, pivot_seq)	Other
8	rweba	July 19, 2011 @ 8:15 pm	Trivial observation: It is easy to see for n=2 and n=3. Actually this can easily be generalized to any convex polygon.First non-trivial case: A triangle with a point in the middle?	perf[judge](value[easy](two_and_three))\newline perf[judge](value[easy](S_convex))\newline perf[query](tri_plus_point)\newline perf[assert](rel[instance_of](problem, two_and_three))	Examples
8.1	Paul	July 19, 2011 @ 8:20 pm	A triangle with an interior point can be dealt with be making sure the interior point is the second pivot we would then form a cycle involving all 4 points which will repeat.	perf[assert](tri_plus_point, tpp_proof)	Proof
8.2	Anonymous	July 19, 2011 @ 8:21 pm	One should start say with a point in the middle and there any line will do.	perf[assert](tri_plus_point, tpp_proof_2)	Proof
8.3	Kristal	July 19, 2011 @ 8:24 pm	choose one of the points of the triangle and choose a line through the point that does not pass through the interior of the triangle then the windmill process should cycle through the vertices of the triangle.	perf[assert](rel[has_property](tri_plus_point, not_all_paths))	Examples
8.4	Garf	July 19, 2011 @ 8:32 pm	It looks like some kind of subdivision in cells occurs (i.e. a subdivision in convex polygons whose vertices are visited counter-clockwise)\ldots	perf[assert](cell_division)	Concept
9	Gal	July 19, 2011 @ 8:15 pm	Angles: If we connect every two dots, then the next pivot is the one that forms the smallest angle in relation with the current pivot.	perf[assert](smallest_angle)\newline rel[structural](smallest_angle, pivot_seq)	Concept
9.1	Gal	July 19, 2011 @ 8:17 pm	\ldots in the direction of rotation of our line L.	***counting this in smallest_angle	Concept
10	Paul	July 19, 2011 @ 8:16 pm	A possible line of enquiry might be to consider how adding additional points effects an already established ``windmill'' this might lead to an inductive solution if adding new points can be related to already established cases.	perf[suggest](meta[strategy](problem, ind_from_examples))\newline rel[structural](ind_from_examples, S)	Conjecture
11	Anonymous	July 19, 2011 @ 8:19 pm	One can start with any point (since every point of S should be pivot infinitely often), the direction of line that one starts with however matters!	perf[assert](rel[equivalent](problem, forall_exists_problem))\newline ???rel[structural](problem, forall_exists_problem)\newline perf[assert](rel[not](rel[equivalent](problem, forall_forall_problem)))\newline ???rel[structural](problem, forall_forall_problem)	Conjecture
11.1	Nemanja	July 19, 2011 @ 8:28 pm	In other words, we can start with any point and `just' need to choose a second point through which will we draw a line.	perf[assert](forall_exists_problem_detail)\newline rel[structural](forall_exists_problem, forall_exists_problem_detail)	Conjecture
11.2	Anonymous	July 19, 2011 @ 8:31 pm	Perhaps even the line does not matter! Is it possible to prove that any point and any line will do?	perf[query](forall_forall_problem)	Conjecture
11.2.1	Thomas H	July 19, 2011 @ 8:35 pm	No, if you start with two points on the convex hull (ordered in the right way) you stay on the convex hull.	perf[challenge](forall_forall_problem, two_conseq_hull)	Examples
11.2.2	Nemanja	July 19, 2011 @ 8:37 pm	It is not possible, two consecutive points on convex hull will not do.	perf[challenge](forall_forall_problem, two_conseq_hull)	Examples
11.2.3	Zhecka	July 19, 2011 @ 8:42 pm	Sure a choice of line is important. Imagine S is a cet of vertices of a convex polygone P (triangle, say) plus one point inside P	perf[challenge](forall_forall_problem, convex_plus_point)	Examples
11.2.3.1	Anonymous	July 19, 2011 @ 8:50 pm	Only the starting point matters. By the problem statement, it appears that the initial angle is irrelevant to the existence of a pivot point P* from which all of S is traversed. Every point in S is a pivot point, but only with a specific range of starting angle (e.g. those consistent with the cycle generating $S$). The union of these intervals must necessarily be $[0,2\pi)$, and thus we can assume WLOG that the starting angle is 0 (and thus we single out a specific point -- or points in the case of $|S| = 2$).	perf[assert](rel[wlog](problem, zero_angle), one_turn)	Proof
11.2.3.1.1	CLH	July 19, 2011 @ 8:57 pm	In fact all points must be achievable within a single full rotation of the line, from a starting P*. Thus the different ways of traversing a subset of S correspond not only to different starting points/angles, but also to different segmentations of $[0,2\pi)$.	perf[agree](one_turn)\newline perf[assert](corr_point_segmentation)	Proof
11.2.3.1.2	Zhecka	July 19, 2011 @ 8:59 pm	Sure. I meant a choice of line is important if you fix a starting point. It was exactly the reply to the parental comment saying that probably we can start with any conficuration ``starting point + starting line''.	perf[agree](rel[wlog](problem, zero_angle), one_turn)	Other
11.3	Seungly Oh	July 19, 2011 @ 9:06 pm	I don't really see this. Could you give this a bit more justification? It seems to me that if only the point matters, we are reduced to only n-1 distinct cases (n being the size of the set S). But we have a lot more cases than this.	perf[challenge](forall_exists_problem, too_many)	Other
12	jc	July 19, 2011 @ 8:23 pm	It might be fun to use projective duality: the space of unoriented lines in the plane is diffeomorphic to the projective plane minus a point, i.e. the open M\"obius strip, which I'll call $M$. Every point $p$ of $S$ corresponds to a line $m_p$ in $M$, and every line $l$ passing through $p$ in the plane corresponds to a point $n_l$ on $m_p$ in $M$. So the projective dual windmill process tracks the position of a point on the arrangement of lines in $M$ dual to the points of $S$. The process begins with $n_l$ on a line $m_p$ and I suppose the clockwise direction tells us which direction we progress along $m_p$. I think the goal is then to show that there exists a starting point on the arrangement such that the trace of the projective dual windmill ``curve'' will hit every single line in this arrangement\ldots?	perf[suggest](meta[strategyl](problem, proj_duality_approach))\newline perf[assert](rel[equivalent](proj_duality_approach, problem))	Concept
12.2	jc	July 19, 2011 @ 10:51 pm	I think that winding a line clockwise around a point in the $z=0$ plane is thus mapped to a point traveling in a clockwise direction on a great circle on the sphere (as viewed from above). This is well defined because none of the great circles pass through the North pole. So the set $S$ in the $z=0$ plane is mapped to an arrangement of great circles on the sphere, and the clockwise rule yields an orientation on each great circle in this arrangement. We just need an argument now to find a directed cycle on this arrangement.	***beginning counted as proj_duality_detail\newline perf[assert](rel[equivalent](problem, new_proj_prob))\newline perf[suggest](meta[goal](new_proj_prob))	Concept
13	Justin W Smith	 July 19, 2011 @ 8:26 pm	It seems that a good place to start is with the set, $A$, of ordered pairs of points, with each ordered pair representing a ``transition'' from one pivot point to the next. Each member of $A$ would be a vertex in a directed graph containing an edge from each ``transition'' to its successor ``transition''. One would then need to show that a cycle exists in this graph for which every point participates in at least one (actually two) of the vertices.	perf[define](A, A_def)\newline perf[define](A_graph, A_graph_def)\newline perf[suggest](meta[goal](rel[has_property](A_graph, has_cycle_2)))\newline rel[structural](A, A_graph)	Conjecture
13.1	Joe	July 19, 2011 @ 8:30 pm	The question here is how to translate the inherent geometrical properties that are required to prove the statement into properties of the graph. (Since obviously it isn't true for all graphs)	perf[suggest](meta[strategy](problem, translate_graph))\newline perf[queryE](rel[has_property](A, X), rel[equivalent](rel[has_property](A_graph, has_cycle_2), rel[has_property](A, X)))\newline perf[assert](rel[not](all_has_cycle_2))\newline rel[structural](all_has_cycle_2, has_cycle_2)	Other
13.1.1	Justin W Smith	July 19, 2011 @ 8:50 pm	There must be $n/2$ distinct cycles since the number of points to the left or right of the line remains constant throughout the process. (Correct me if I'm wrong.)	perf[assert](rel[has_property](A_graph, half_partial_cycles), half_thepoints)\newline perf[assert](half_thepoints)\newline rel[structural](half_thepoints, S)\newline rel[structural](half_thepoints, l)\newline rel[structural](half_thepoints, P)	Proof
13.1.1.1	Justin W Smith	July 19, 2011 @ 8:55 pm	Ok. I think the solution might involve this observation, with the observation that every point participates in a ``splitting'' lines (one with $n/2$ points on one side).	perf[agree](half_thepoints)\newline perf[suggest](meta[auxiliary](problem, forall_split))\newline perf[suggest](meta[auxiliary](problem, half_thepoints))	Conjecture
13.1.1.2	Austin	July 19, 2011 @ 9:13 pm	This seems to be incorrect. Consider $A=(0,2)$, $B=(3,2)$, $C=(3,0)$, $D=(0,0)$, $E=(2,1)$. Start with $\mathit{ED}$ pivoting around $D$; this divides the other points into two $(A,B)$ and one $(C)$. The next line is $\mathit{DC}$, which leaves $A,B,E$ all on one side.	perf[challenge](half_thepoints, 5_counterex)\newline perf[assert](rel[instance_of](S, S5))\newline rel[structural](S5, 5_counterex)	Examples
13.1.1.2.1	Zhecka	July 19, 2011 @ 9:29 pm	If you start with $\mathit{DE}$ turning around $D$ and the next line is $\mathit{DC}$ it means that you start with ``$\mathit{DE}+\epsilon$'', that is you should also count the point ($E$) at the side of $(A,B)$. In the seim vein, turning $\mathit{CD}$ around $C$ you should count ($D$) on the one side and $(A,B,E)$ on the other. So the number of points persists the same.	perf[challenge](perf[challenge](half_thepoints, 5_counterex), actual_seq)	Proof
14	Anonymous	July 19, 2011 @ 8:27 pm	I'm not sure but as no three points are collinear, one can always find a line which splits the points into two sets whose number of elements differ at most one?	perf[assert](forall_split, rel[has_property](S, not_colin))	Conjecture
14.1	Thomas H	July 19, 2011 @ 8:28 pm	That is surely true. How could this help us?	perf[agree](forall_split)\newline perf[query](value[useful](forall_split))	Other
14.1.1	Anonymous	July 19, 2011 @ 8:41 pm	Something like one can find this no matter how we choose the first point. Then in some time the windmill must be parallel to the line through these points. This line must be unique or else it splits the points such that number of elements differ at least two.	perf[assert](value[useful](forall_split))\newline perf[assert](meta[auxiliary](parallel_line, forall_split))\newline rel[structural](parallel_line, l)	Proof
14.1.1.1	Justin W Smith	July 19, 2011 @ 8:47 pm	It appears that the number of points to the ``left'' or ``right'' of the line is constant through the entire process!	perf[assert](half_thepoints)	Conjecture
14.2	Garf	July 19, 2011 @ 9:14 pm	I think this solves the problem. Start with a line which separates the points into two parts of roughly same size (their cardinal differ by at most one, not counting the point to which the line is attached). Then run the process until the line is ``upside-down'', and so has turn by exactly $\pi$. Every point has gone from the right of the line to the left of the line (easy to see is the number of point is odd, you have to be a bit more crafty if it is even), and no point can go from left to right or right to left without touching the line. Add the previous remarks (the process will always come back to its initial configuration), and every point will be visited infinitely often.	perf[define](init_line, init_line_def)\newline rel[structural](init_line_def, forall_split)\newline proof_sugg := perf[assert](rel[equivalent](init_turn_by_pi, points_switched_sides))\newline perf[assert](problem, proof_sugg, half_thepoints)\newline *** or perf[assert](rel[stronger](proof_sugg, problem))???\newline perf[assert](rel[instance_of](parallel_line, init_turn_by_pi))\newline rel[structural]((init_turn_by_pi, init_line)	Proof
14.2.1	Gal	July 19, 2011 @ 9:23 pm	Very nice! Don't we run into problems with a convex hull though? Take a square with a point in the middle (M) and pass the diagonal of the square (not through M) -- it seems to me M is never visited (though I may be wrong here). I think we should be more specific in our initial choice of line, maybe?	perf[judge](value[beautiful](proof_sugg))\newline perf[challenge](proof_sugg, convex_ex_5)\newline rel[structural](convex_ex_5, S)\newline rel[structural](convex_ex_5, l)\newline rel[structural](convex_ex_5, P)	Examples
14.2.1.1	Gal	July 19, 2011 @ 9:28 pm	No. This example is false. :)	perf[retract](convex_ex_5)	Other
14.2.2	Zhecka	July 19, 2011 @ 9:35 pm	Yes, it seems to be a correct solution!	perf[agree](proof_sugg)\newline perf[assert](rel[stronger](proof_sugg, problem))	Other
14.2.3	Gal	July 19, 2011 @ 9:42 pm	This seems to be right, but there something I don't understand. Please see if you can help me with it: Start with a square and a point inside it (M): start with a tangent to the square (your solution demands a more equal division of points, I know). When we get to the opposite vertex of the square all points moved from one side of the line to the other, but not all points have been visited (M will never be visited). The argument is almost exactly the same, so it seems that the equal division of points plays a crucial role, but I don't understand what role exactly. Can we pin it down precisely?	perf[assert](half_points_essential, convex_ex_6)\newline perf[assert](rel[instance_of](S, convex_ex_6))\newline rel[structural](convex_ex_6, l)\newline perf[assert](rel[has_property](convex_ex_6, rel[not](has_cycle)))\newline perf[assert](rel[has_property](convex_ex_6, points_switched_sides))\newline perf[queryE](why_half_points_essentia(X))\newline rel[structural](why_half_points_essential, half_points_essential)	Examples
14.2.3.1	Garf	July 19, 2011 @ 9:47 pm	I f I understand well your example : the problem is that you must give an orientation to the line. Then, left and right are define with respect to this orientation : if the line has made half a turn, then left and right are reversed. In your example, I think most of the point move from, say, the part et the top of the line to the part at the bottom of the line, but always stay at the right of the line.	perf[challenge](rel[has_property](convex_ex_6, points_switched_sides))	Concept
14.2.3.1.1	Gal	July 19, 2011 @50	Got it! Kind of like a turn number in topology. Thanks! :)	perf[agree](perf[challenge](rel[has_property](convex_ex_6, points_switched_sides)))	Other
14.2.4	Anonymous	July 19, 2011 @ 9:46 pm	My bachelor thesis supervisor said that one can't use the word cardinal if we talk about finite sets. One has to use the words ``number of elements''.	???	Other
14.2.5	Jerzy	July 19, 2011 @ 9:49 pm	I'm trying to understand why the initial line must split the points into two (almost)-equal sets. I guess it's so that when it rotates 180 degrees, the line is guaranteed to be back in the same place again, i.e. dividing it into the same two equal sets, so each point must have switched from right to left\ldots so the line must have visited each point. If instead you start the line tangent to the convex hull, with all non-pivot points to its right, then when it rotates 180 degrees it will STILL have all non-pivot points to its ``right''. Yes?	perf[assert](rel[equivalent](points_switched_sides, half_thepoints), forall_split)	Examples
14.2.5.1	Garf	July 19, 2011 @ 9:50 pm	That's it.	perf[agree](rel[equivalent](points_switched_sides, half_thepoints))	Proof
14.2.5.1.1	Jerzy	July 19, 2011 @ 10:06 pm	Cool. One more thing I'm trying to understand: If there are an even number of non-pivots, there is exactly one vertical line that passes through a pivot that divides the remaining points in half. So when the line rotates 180 degrees, it'll have to pass through that point again. But if there are an odd number of non-pivots, then there are two choices of pivot point for the vertical line separating the non-pivots into almost-halves. Does it matter which one you use? Do you need to specify anything like ``the side with one extra point is the side that will get hit next''? Or does that not matter? In other words, when there are an odd number of non-pivots, and then the line hits a 2nd point so it's on two points at once, you could either have equal points on either side, or you could have k on one side and (k-2) on the other side. Does this cause a problem that requires an appropriate choice of initial pivot and rotation-direction?	perf[assert](rel[case_split](init_line, even_case, odd_case))\newline perf[assert](even_case)\newline perf[queryE](next_pivot, X)\newline perf[assert](rel[case_split](odd_case, equal_split, diff_2))	Proof
14.2.5.1.1.1	Garf	July 19, 2011 @ 10:28 pm	And that is the difference between the odd and even cases. Anyway, the choice of the starting point (between the two possible choices, say, A and B) does not matter : if you start from A, then after half a turn you will be on point B, so the two choices of starting point (with the given starting orientation) belong to the same orbit.	perf[agree](rel[case_split](init_line, even_case, odd_case))\newline perf[assert](rel[equivalent](equal_split, diff_2))	Proof
15	Varun	July 19, 2011 @ 8:27 pm	We could perhaps consider ``layers'' of convex hulls (polygons) .. like peeling off an onion. If our line doesn't start at the ``core'' (innermost) polygon then I feel it'll get stuck in the upper layers and never reach the core.	perf[suggest](meta[strategy](problem, induction_hulls_2))\newline rel[structural](induction_hulls, induction_hulls_2)\newline perf[assert](rel[stronger](problem, inner_start))	Concept
15.1	A	 July 19, 2011 @ 8:46 pm	I think that is a good start, thanks Varun!	perf[agree](meta[strategy](probem, induction_hulls_2))\newline perf[agree](rel[stronger](problem, inner_start))	Other
15.2	Srivatsan Narayanan	July 19, 2011 @ 8:48 pm	This was suggested by Haggai Nuchi (comment 4). But it's hard to keep track of the process since it keeps switching between multiple layers in a seemingly arbitrary fashion (in fact, we are looking for a windmill that does exactly this).	perf[assert](rel[equivalent](induction_hulls_2, induction_hulls))	Concept
16	Pingback	~	~	~	~
17	Anonymous	July 19, 2011 @ 8:39 pm	The windmill process defines a function f from the set of all pairs of points to itself, with the condition that f(ab)=bc for some c. Is it true that for any such function we can find a permutation a_1,a_2,\ldots a_n such that f(a_i,a_{i+1}) = a_{i+1} a_{i+2} ?	perf[define](f_functions, overlap)\newline rel[structural](A, f_functions)\newline perf[query](rel[has_property](f_function, corresp_perm))	Concept
17.1	Srivatsan Narayanan	July 19, 2011 @ 8:51 pm	No, e.g.: f(ab)=ba and f(ba) = ab. The geometric properties of f seem crucial.	perf[challenge](rel[has_property](f_function, corresp_perm), pair_ex)	Examples
17.1.1	Austin	July 19, 2011 @ 8:55 pm	But even if f(ab)=ba and f(ba)=ab, there may be some other cycle that works. For example, if n=3, we might have f(ac)=cb, f(cb)=bc, f(bc)=ca, f(ca)=ac. So your counterexample isn't actually a counterexample (yet).	perf[challenge](perf[challenge](rel[has_property](f_function, corresp_perm), pair_ex), not_univ)	Proof
17.1.1.1	Thomas H	July 19, 2011 @ 8:58 pm	The counterexample is f(a b) = (b a) for all pairs (a,b).	repair[existential_to_universal](pair_ex, pair_ex_univ)	Examples
17.1.1.2	Austin	July 19, 2011 @ 9:03 pm	On the other hand, if n=3, then we could have cycles aba, bcb, cac, which would form a counterexample. This is definitely ``ungeometric,'' since the cycles are too short (ac and ca are actually the same line). But if n=5, then we could have cycles abcda, acea, bedb -- another counterexample, and this one survives the preceding objection. So I'm ready to agree that geometry matters.	perf[retract](perf[challenge](perf[challenge](rel[has_property](f_function, corresp_perm), pair_ex), not_univ))	Examples
17.2	g	July 19, 2011 @ 8:53 pm	No. For instance, consider the f that simply swaps the points in the pair you hand it: f(ab) = ba, f(ba) = ab, for all choices of a,b.	perf[challenge](rel[has_property](f_function, corresp_perm), pair_ex_univ)	Concept
17.3	Austin	July 19, 2011 @ 8:53 pm	We don't need it to be a permutation, just a sequence which contains each point at least once (possibly with repetition).	perf[assert](rel[has_property](f_function, corresp_seq))\newline repair[less_conditions](corresp_perm, corresp_seq)	Proof
18	Anonymous	July 19, 2011 @ 8:41 pm	Since the points are in general position, you could define ``the wheel of $p$'', $w(p)$ to be radial sequence of all the other points $p'\neq p$ around $p$. Then, every transition from a point p to q will ``set the windmill in a particular spot'' in $q$. This device tries to clarify that the new point in a windmill sequence depends (only) on the two previous points of the sequence.	perf[define](wheel_of_p, wheel_def)\newline rel[structural](wheel_of_p, p)\newline perf[assert](dep_on_2)\newline rel[structural](wheel_of_p, dep_on_2)]	Concept
18.1	Austin	July 19, 2011 @ 8:48 pm	Yes. Geometry constrains the possible lists of $w(P_1)$, $w(P_2)$, etc., but I wonder if the geometry actually matters. Suppose we associate to each p an *arbitrary* radial sequence consisting of all $p' \neq p$. Does the conclusion of the problem still hold, or are there counterexamples?	perf[query](rel[stronger](X, dep_on_2))	Conjecture
18.1.1	Austin	July 19, 2011 @ 8:51 pm	Never mind, this is what comment \#17 is suggesting.	perf[retract](perf[query](rel[stronger](X, dep_on_2)))	Other
19	Seungly Oh	July 19, 2011 @ 8:48 pm	A question: Does the windmill process eventually form a cycle?	perf[query](rel[has_property](pivot_seq, has_cycle))	Conjecture
19.1	Austin	July 19, 2011 @ 8:49 pm	Yes, see comment \#2 and replies.	perf[assert](rel[has_property](pivot_seq, has_cycle))	Other
19.2	Thomas H	July 19, 2011 @ 8:50 pm	I think so: the function f from comment \#17 is a permutation on the pairs of points.	perf[assert](rel[has_property](pivot_seq, has_cycle), rel[has_property](f_function, is_perm_pairs))	Proof
19.3	Seungly Oh	July 19, 2011 @ 8:50 pm	I guess it should, since there are infinite many iterations and only finite options.	perf[assert](rel[has_property](pivot_seq, has_cycle), pigeonhole_paths)	Concept
20	Zhecka	July 19, 2011 @ 8:49 pm	By the way, if we get as S the four following points: vertices of an equilateral triangle T and its center, what will be a cooresponding windmill that passes each point infinitely often? It seems that after wa fall on one of the vertices of T we will never return to its center.	perf[challenge](problem, equi_tri_stuck)	Examples
20.1	Zhecka	July 19, 2011 @ 8:51 pm	I've just found the answer in brunch 3.	perf[retract](perf[challenge](problem, equi_tri_stuck))	Other
21	Thomas H	July 19, 2011 @ 8:56 pm	Suppose that all but two points lie on the convex hull of the points. Start with the two points (ab) not on the convex hull. Then, since the function f in \#17 is a permutation, $f^{(k)}(ab) = (ab)$, for some $k$. Also, it seems ``clear'' that all points on the convex must have been visited (but how to see that formally?)	perf[assert](convex_plus_two, f_function_repeat)\newline perf[assert](rel[instance_of](problem, convex_plus_two))\newline rel[structural](f_function, f_function_repeat)\newline perf[suggest](meta[goal](rel[has_property](f_function, touch_all)))	Examples
22	Anonymous	July 19, 2011 @ 9:05 pm	Pick a smallest angle PQR and take the pair to be Q and PQ.	perf[define](smallest_angle)	Concept
22.1	Anonymous	July 19, 2011 @ 9:21 pm	Consider the first time the line rotates past Q but misses it. Let S be the pivot and T be the pivot before $S$. Suppose $Q'$ is the point such that angle $\mathit{STQ}'$ is less than $\mathit{STQ}$. Then is it feasible to prove that angle $\mathit{PQ'R}$ must be smaller than $\mathit{PQR}$, thus deriving a contradiction?	perf[suggest](meta[strategy](problem, proof_contrad))\newline rel[structural](proof_contrad, smallest_angle)\newline perf[query](value[feasible](proof_contrad))	Conjecture
23	Srivatsan Narayanan	July 19, 2011 @ 9:08 pm	Can someone give me *any* other example where the windmill cycles without visiting all the points? The only one I can come up with is: loop over the convex hull of S.	perf[assert](rel[instance_of](convex_hull_stuck, equi_tri_stuck))\newline perf[query](rel[stronger_than](unworking_path, convex_hull_stuck))	Conjecture
23.1	Thomas H	July 19, 2011 @ 9:11 pm	Place many equidistant points on a circle, and also take the center. Then, start with the line which uses two points adjacent points on the convex hull, but in the different order than you did previously (i.e., so that it does *not* just loop over the convex hull).	perf[challenge](rel[stronger_than](unworking_path, convex_hull_stuck), circle_ex)	Examples
23.1.1	Srivatsan Narayanan	July 19, 2011 @ 9:19 pm	Let me check that I got the example correctly: is this ``a point inside a regular polygon''? Isn't it established in an early comment that the example of a point inside an equilateral triangle indeed visits *all* the points? Can you clarify the difference here?	perf[query](rel[instance_of](convex_plus_point, circle_ex))\newline perf[assert](rel[has_property](equi_tri, cycle_spans_S))\newline ???	Other
23.1.1.1	Thomas H	July 19, 2011 @ 9:21 pm	I wanted to place many more points on the unit circle -- say 100. Also, even with the equilateral triangle and the point inside, it depends on how you start -- you may not visit all points.	perf[assert](rel[has_property](equi_tri, not_all_paths))\newline perf[assert](rel[has_property](circle_ex, not_all_paths)	Examples
23.2	Seungly Oh	July 19, 2011 @ 9:19 pm	take a regular pentagon (ABCDE) for example. In the ``star'' formed by connecting all the vertices, place an extra point on the center of the star. and begin your windmill from the line AC (with A as the first pivot). I believe that the lines here stay strictly outside the center of the star.	perf[assert](rel[has_property](star_ex, rel[not](cycle_spans_S)))	Examples
23.2.1	Joe	July 19, 2011 @ 9:25 pm	Okay, but the *points* this loops around do form the convex hull though (or have I misunderstood?). Can we find an example where we have a cycle, not visiting all points, where the *points that are visited* do not form a convex set?	perf[assert](rel[has_property](star_ex, convex_hull_stuck))\newline perf[judge](rel[not](value[useful](star_ex)))	Concept
23.2.1.1	Seungly Oh	July 19, 2011 @ 9:34 pm	forgive my lack of rigor in the following statement: I believe that there can injected ``harmless'' points, where the overall covered area by the rotating line is essentially same (or vary by measure of epsilon). In my experiment, you are able to inject such points in the interior of the pentagon. Thus the points do not form a convex polygon. Does that make any sense? Of course, I may be wrong in this.	perf[challenge](rel[stronger_than](unworking_path, convex_hull_stuck), star_ex)	Conjecture
23.2.1.2	Varun	July 19, 2011 @ 9:43 pm	Say you have an equilateral triangle ABC with a smaller equilateral triangle DEF sitting inside ABC. (For simplicity assume DEF has its sides parallel to that of ABC and has the same orientation). Take point G to be somewhere inside DEF. Now Start the line AC with pivot at A (so that the next point it'll hit is F). You'll visit all points except G.. so the set of visited points(i.e. A,B,C,D,E,F) does not form a convex polygon.	perf[challenge](rel[stronger_than](unworking_path, convex_hull_stuck), double_triangle_ex)	Examples
23.2.2	Srivatsan Narayanan	July 19, 2011 @ 9:26 pm	I am sure I am making a mistake, but my windmill seems to ``drift off'' to the convex hull in the second step. Can you list a few initial vertices that the windmill is supposed to visit so that I can track the error?	perf[queryE](rel[has_property](star_ex, span_path))	Proof
23.2.2.1	Seungly Oh	July 19, 2011 @ 9:29 pm	okay. in order of the vertices serving as pivot, I have: A, B, E, A, D, E, C, D, B, etc..	perf[assert](rel[has_property](star_ex, real_span_path))	Proof
23.2.2.1.1	Srivatsan Narayanan	July 19, 2011 @ 9:44 pm	Yes, I am happy with this example. Although it still does use the points only on the convex hull, it definitely at least sweeps inside as well. Thanks!	perf[agree](rel[has_property](star_ex, real_span_path))\newline perf[assert](rel[has_property](real_span_path, sweeps_inside))	Other
23.3	Joel	July 19, 2011 @ 9:22 pm	Moreover is there an example where the space which is not ``swept'' by the lines (as the windmill goes on) is unbounded? (we know that that space contains all the points that are not picked, and for the convex hull example it is just the interior of the polygon)	perf[define](swept_space, swept_space_def)\newline perf[queryE](X, rel[instance_of](S,X), swept_unbounded(X)))	Conjecture
23.3.1	Seungly Oh	July 19, 2011 @ 9:25 pm	I do not believe that this is possible. Since the rotation is unstopped and always counterclockwise, the line will inevitably sweep through the unbounded space outside the convex hull of the points when a full rotation has taken place.	perf[assert](no_swept_unbounded, sweeps_out)\newline rel[structural](no_swept_unbounded, swept_unbounded(X))	Conjecture
23.3.1.1	Srivatsan Narayanan	July 19, 2011 @ 9:28 pm	I believe Joel hopes to show that the area *not swept* is always bounded (or get a counterexample).	??? reported speech	Other
23.3.1.1.1	Seungly Oh	July 19, 2011 @ 9:36 pm	I think it is always bounded and lies inside the convex hull. I believe that is graphically obvious. But how does this help?	perf[assert](no_swept_unbounded)\newline perf[judge](value[easy](no_swept_unbounded))\newline perf[query](value[useful](no_swept_unbounded))	Conjecture
23.3.1.1.1.1	Srivatsan Narayanan	July 19, 2011 @ 9:40 pm	Oh yes, it does seem so. And yes, I am not sure it would help either.	perf[agree](value[easy](no_swept_unbounded))\newline perf[query](value[useful](no_swept_unbounded))	Other
23.4	Haggai Nuchi	July 19, 2011 @ 9:28 pm	Take a large number of points on a circle, plus another point at the center of the circle. Take your initial point on the circle, and second point some distance away (e.g. a quarter of the way around). Now perturb some of the points so that they lie just inside the circle. It seems clear to me that the windmill will miss the center point and yet will hit some of the points not on the convex hull.	perf[challenge](rel[stronger_than](unworking_path, convex_hull_stuck), circle_ex_mod)\newline rel[structural](circle_ex, circle_ex_mod)	Examples
23.4.1	Srivatsan Narayanan	July 19, 2011 @ 9:39 pm	@Thomas @Seungly @Haggai Thank you all for your examples. I haven't understood them fully yet.  I'll think about them for some time and get back if I have questions.	?? social glue	Other
23.5	Mark Bennet	July 19, 2011 @ 9:58 pm	I think that there may be a notion of ``innermost point'' stripping consecutive convex hulls, and it may be possible to stay outside any particular convex hull, which can (it seems to me) be treated as an overgrown point. Actually there may be a proof there in taking the convex hull and treating the internal structure as a single point and showing you can do that, then growing that point into the second level convex hull with a single point inside. Or alternatively growing outwards -- solving for the internal structure first (which seems possibly cleaner) -- though as I post this there are some other neat comments out there for different approaches.	perf[suggest](meta[goal](stay_out_hull))\newline perf[suggest](meta[strategyl](problem, out_to_in_induction))\newline perf[suggest](meta[auxiliary](out_to_in_induction))\newline perf[suggest](meta[strategyl](problem, in_to_out_induction))\newline perf[suggest](meta[auxiliary](in_to_out_induction))	Concept
24	Thomas H	July 19, 2011 @ 9:19 pm	Let's say you start with the vertical line which has n/2 points on the right, and n/2 points on the left. You turn it -- eventually it will be vertical again. Now n/2 points are on the left and n/2 points on the right, but the left and right have reversed. You have only switched points 1 by 1, so to say -- so you must have visited each point at least once?	perf[define](init_line_even, init_line_even_def)\newline proof_sugg_2 = perf[assert](rel[equivalent](rel[has_property(init_line, turn_by_pi_mod), points_switched_sides_mod]))\newline perf[assert](rel[stronger](proof_sugg_2, problem))	Proof
24.1	Garf	July 19, 2011 @ 9:31 pm	I believe this is a solution (see my comment to \#14), although this needs some polishing (I guess there is an odd / even number of point distinction to do).	perf[assert](rel[stronger](proof_sugg_2, problem))\newline perf[suggest](meta[goal](meta[case_split](proof_sugg_2, even_case, odd_case)))	Proof
24.1.1	Thomas H	July 19, 2011 @ 9:33 pm	Right -- I'm sorry, I didn't see your solution there! :)	?? social glue	Other
24.2	Andrew L	July 19, 2011 @ 9:33 pm	This implies the windmill is unique, correct? For any orientation there is only one line (up to irrelevant translation over a range containing no points) dividing the points in half. Actually I guess it would imply the windmill is unique for an even number of points and there are two distinct windmills for an odd number of points.	perf[query](problem_unique_windmill)\newline perf[assert](problem_unique_windmill, unique_div_line)\newline repair[existential_to_unique](problem, problem_unique_windmill)\newline perf[challenge](problem_unique_windmill)\newline repair[additional_conditions](problem_unique_windmill, problem_unique_windmill_even)\newline perf[assert](problem_unique_windmill_even, unique_div_line)\newline perf[assert](problem_two_for_odd, unique_div_line)	Conjecture
24.2.1	Joel	July 19, 2011 @ 9:42 pm	I don't see why a good windmill must have half points in each side.	perf[challenge](problem_unique_windmill_even)\newline perf[assert](rel[not](rel[stronger](cycle_spans_S, init_line_even_def)))	Other
24.2.1.1	Andrew L	July 19, 2011 @ 9:45 pm	Ah, so. I'll shut up now. :-)	perf[retract](problem_unique_windmill_even)	Other
24.2.1.1.2	Jerzy	July 19, 2011 @ 9:52 pm	Maybe it's possible in *some* cases to get a good windmill with less than half the points on each side, but having half the points on each side will *guarantee* a good windmill?	perf[agree](rel[not](rel[stronger](cycle_spans_S, init_line_even_def)))\newline perf[assert](rel[stronger]( init_line_even_def, cycle_spans_S))	Conjecture
24.3	Joel	July 19, 2011 @ 9:39 pm	Yes, I think this solves it. Suppose it doesn't get a point a. Then a is always at the same side of the line, but it starts in the right and ends in the left, contradiction.	perf[agree](rel[stronger](proof_sugg_2, problem))	Proof
25	Austin	July 19, 2011 @ 9:22 pm	Using the terminology from comment \#18, the average angle formed at p by two consecutive points in its ``wheel'' is pi/(n-1), right? And the windmill can't cycle until it's turned through a total angle of pi, at least. Is there a pigeonhole argument?	perf[assert](wheel_portion)\newline rel[structural](wheel_portion, wheel_of_p)\newline perf[suggest](meta[strategy](problem, meta[auxiliary](pigeonhole_geom, wheel_portion)))	Concept
26	Andrew L	July 19, 2011 @ 9:22 pm	Building on comment 10, we could try to induct on the number N of points. Suppose we know there is always a conforming windmill of N points; given N+1 points, show that you can choose one point to label the ``newcomer'' so that a conforming windmill of the remaining N points must extend to a conforming windmill of the N+1 points.	perf[suggest](meta[strategy](problem, induction))\newline rel[structural](induction, n)	Conjecture
27	Terence Tao	July 19, 2011 @ 9:50 pm	I've added the solution at comment \#14 to the wiki as the first completed solution (although some additional details could do with being filled in there; please feel free to do so!). This solution appeared 74 minutes after the mini-polymath project started, which is a respectable time. Congratulations to all participants, and hope you enjoyed the project. :-) Of course, there could still be alternate solutions and other loose ends. (For instance, it would be curious to see whether there is a nice proof using the projective duality language from comment \#12, or whether the induction strategy can be made to work; there is also the question of whether the cycles are completely classified by the number of points to the left and right of a line.)	perf[agree](rel[stronger](proof_sugg, problem))	Other
